tail file.txt //output the last part of files по умолчанию показывает последние 10 строк
tail -f file.txt //-f follow выводит новые добавленые строки. чтобы закончить вывод ctrl+c
tail -1000f file.txt // следит за обновлениями файлов, показывает последние 1000 строк
tail --help

cat file1 // выводит на экран содержимое файла
cat file1 file2 //склеивает два файла

head file.txt // output the first part of files по умолчанию показывает первые 10 строк 
head -n 1000 file.txt // первые 1000 строк

touch file.txt // создание пустого файла
touch .file.txt //создание скрытого файла
> file.txt // создание файла
echo "hello mr Zhan" > file.txt // осторожно перезаписывает файл на hello mr Zhan
echo "добавление данных к файлу, а не перезапись" >> file.txt // добавление данных

mv arg1.txt arg2_dir/ //перемещение файла в папку arg2_dir
mv file1.txt file2.txt //переименование файла
mv -i file1.txt file2.txt // предупредит о перезаписывании если файл существует
mv -t dest/ file1 file2 file3 // перемещение в папку всех файлов

cp -i file1.txt dir/  //копирование файла в папку с предупреждением
cp file1 file2 //копирование содержимого файла1 в файл2, даже если файл2 не существует
cp -r dir1 dir2 //копирование содержимого дир1 в дир2 даже если его нет.


rm -i file.txt // удаление файла с предупреждением

ls -a //показывает список обычных и скрытых файлов

*** запуск нескольких команд за раз ***
Например, если нам нужно выполнить несколько команд последовательно, не обязательно вводить каждую по отдельности. Можно перечислить их через точку с запятой:
echo -n "Hello, "; echo "World!" // -n не будет вставлен символ перевода строки \n


Если нам нужно выполнить список зависимых друг от друга команд, для их разделения нужно использовать оператор &&.
В таком случае следующая команда в списке будет выполнена только при условии успешного выполнения предыдущей.
echo -n "Hello, " && echo "World!"


Оператор || действует наоборот — запускает следующую операцию при условии, что первая не выполнилась или завершилась с ошибкой.
wrongCommand || echo "Что-то пошло не так!"

Также можно запускать команды параллельно. Для этого в конец команд добавляется символ &, каждая команда заключается в круглые скобки, которые между тем разделяются между собой точкой с запятой:
(echo "Кто сказал, что убить двух зайцев" &); (echo "одним махом нельзя?" &)


Чтобы запустить скрипт script.sh на сервере, нужно выполнить два шага: 
    Настроить права на запуск файла для пользователей:
    chmod +x ./script.sh

    Запустить скрипт. Если вы находитесь в той же директории, где лежит скрипт, достаточно вызвать его по имени:
    ./script.sh

    В некоторых случаях нужно использовать команду sh либо указать путь к исполняемому файлу командной оболочки:
    sh ./script.sh
    либо
    /bin/bash ./script.sh
    Если вы находитесь в другой директории, для запуска нужно указать полный путь к скрипту. 


Чтобы иметь возможность запускать скрипт из любого места на сервере одной простой командой, можно создать для него алиас — короткую команду (псевдоним),
 которая будет ассоциироваться системой с полным вызовом скрипта.
Весь список существующих алиасов системы можно вывести с помощью команды alias

Создать свой постоянный алиас можно с помощью файла .bashrc, размещённого в домашнем каталоге вашего пользователя. Нужно открыть его для редактирования:
vi ~/.bashrc

В соответствующем разделе нужно добавить ваш алиас в следующем формате:
alias [короткая команда]='[исходная команда]'

*****Выполнение в фоновом режиме*****
Некоторые команды могут временно блокировать или усложнять работу в терминале. Например, когда запущенный процесс долго выполняется или выводит в консоль большие объёмы не особо полезного текста. Такие команды можно запускать в фоновом режиме. Тогда система будет выполнять их «на заднем плане», а вы продолжите работать и не будете ждать выполнения очередной операции.
Чтобы запустить команду в фоновом режиме, достаточно добавить в конце знак «&»:
sleep 3600 &

Если вам нужно переместить на задний план активный процесс, тогда нужно приостановить процесс его выполнения сочетанием Ctrl + Z и ввести в консоли команду bg

Вывести список команд, запущенных в фоновом режиме, можно с помощью команды 
jobs -l
Важно помнить, что фоновый режим привязан к сессии — при выходе из терминала все процессы, запущенные через него, будут прерваны. Этого можно избежать, выполнив нужную команду через nohup:
nohup sleep 3600 &


Команды, запущенные в фоновом режиме, при наличии ошибок будут отправлять их в терминал — что не всегда удобно. Можно перенаправить вывод ошибок. В следующем примере ошибки вместо вывода в терминал будут записаны в файл error.log:
sleep 3600 2>>error.log &

Вернуть процесс на передний план можно, введя команду fg. Если процессов несколько, потребуется указать идентификатор задачи ID. Его можно посмотреть в выводе команды jobs -l (число в квадратных скобках).
fg %ID





типы файлов в линукс:
1. обыкновенные файлы;
2. дириктории;
3. символьные устройства;
4. блочные устройства;
5. соккеты;
6. каналы;
7. символьные ссылки;

Посмотреть тип файла: ls -l

утилита ncdu - показывает размер папки и вложенных файлов - необходимо установить
-r значит рекурсивно (удалить файлы в папке и во вложенных папках тоже) - осторожное применение

ls -R //показывает все файлы и папки рекурсивно


мягкие сслыки и жёсткие ссылки
мягкие ссылки как ярлыки в windows - файл с типом ссылка, который указывает на другие файлы.
Они хранят адрес файла. Мягкие они называются потому что они за файлом не следят.
Если переместить, удалить файл - мягкая ссылка перестанет работать.
ln -s полный_адрес/file link //создание мягкой ссылки

жёсткие ссылки работают не с адресами файлов, а с индексными дескрипторами.
Хранит метаданные в том числе и место на диске.
У каждого файла есть индексный дескриптор (можно увидеть ls -li)
ln file.txt hardlink// создание жёсткой ссылки
теперь inode совпадают у файла и жёсткой ссылки ls -li
 при копировании файлов inode у них различаются. Теперь файлы живут каждый по себе.

-----USERS-----
sudo useradd zip // добавление нового пользователя в ОС, без домашней директории и без пароля
sudo useradd -m username // с домашней директирией

cat /etc/passwd //посмотреть на пользователя, есть ли пароль
sudo passwd username // добавить пользователю пароль Unix по умолчанию

sudo userdel username //удаление пользователя
sudo userdel -r username //удаление вместе с домашней директорией

su username //переключиться на нового пользователя

--groups--
cut -d: -f1 /etc/passwd //посмотреть список пользователей

sudo groupadd lawyers // создали группу юристов
getent group // проверка создания группы

sudo usermod -aG lawyers username //добавили пользователя в группу 
getent group lawyers // проверяем что пользователь добавился в группу

sudo gpasswd --delete username lawyers //удаление пользователя из группы

----- Права доступа -----
---смена собственника файла---
ls -la
sudo chown username:group test-1.sh
ls -la

sudo chmod g=r file_or_dir #доступ для чтения для всей группы
g=w - вносить изменения для группы
g=x - выполнять для группы

o - other 
o+r
o+w
o+x

sudo chmod a+x file.sh //исполнение всем группам (a - all)
sudo chmod g-x file.sh //запрет исполнения всем группам
sudo chmod o-x file.sh //запрет исполнения другим




 user	group	other
-rwx	rwx	rwx
 111	111	111
 7	7	7

 
-rwx	---	---
 7	0	0

-rw-	rw-	rw-
 110	110	110
 6	6	6

sudo chmod 666 file.sh //запрет исполнения

---grep and find---
find - для поиска файлов по именам и метаданным - рекурсивно по всем папкам вниз
find #без аргументов покажет список всех файлов в директории откуда был запуск
find -name "filename" # из директории где типо есть файл
find -iname "filename" # без учёта регистра

find -name "test*" or find -iname "test*" #регулярные выражение

find -type # 7 типов файлов
find . -type d #найти в текущей папке все папки
find . -type f #вывести файлы

find . -type d -name "dir*"
 
поиск по размеру файла
find . -size +1M # больше 1 Мега байта
find . -size -1M

find . -emty # ничего не содержит
find . -mmin -10 #модификация меньше 10 минут назад
find . -mtime -5 # 5 дней назад


grep - чаще всего используется для поиска по содержимому файла

ps aux | grep process_name # поиск и вывод нужного процесса


******************process*************
состояния: 
1. Готовность
2. Выполнение
3. Ожидание

виды: 
*процессы запущенные пользователем
*демоны (процессы запущенные системой)

посмотреть дерево процессов: pstree
системные вызовы:
*fork
*exec
*exit
*kill

sleep 100 & # процесс засыпает в фоне
nohup sleep 100 & # процесс не завершится при закрытии терминала


jobs -l
fg pid #выводы запущеных процессов

top, htop # утилиты просмотра процессов и их атрибутов

kill pid # экстренное завершение процесса

ps - это утилита отображающая запущенные на данный момент процессы.
Выводит снимок состояния процессов.

ps # без ключей выводит инфу о запущенных процессах конкретной оболочки, в которой я нахожусь.
ps -A или ps -e #выводит список всех активных процессов на linux системе в generic (Unix/Linux) формате.
ps au или ps aux #-||- в bsd формате

ps -x #вывод всех процессов владельцем которых является запустивший команду.
ps -fu root или ps -fU 0 #вывод всех процессов конкретного пользователя по его имени или id
ps -eo pid,user,cmd #id процесса, пользователь, команда  
ps aux | grep pid

pkill process_name

killall chrome

pgrep chrome

pgrep -u zip1982b # посмотреть процессы запущенные пользователем.

uptime # сколько пользователей залогинилось


************** ssh **********************
чтобы подключиться к серверу по ssh, необходимо что бы на сервере был установлен сервер ssh и включен.
как правило первый вход (как администратор) (имея логин и пароль) происходит по логину и паролю: ssh root@ip-address <enter> далее вводим пароль
необходимо создать другого пользователя (чтобы не работать под root - в целях безопасности) и включить его в группу sudo (если её нет то создать)


 
далее необходимо настроить вход для пользователей по ssh ключам:
необходимо сгенерировать пару ключей (публичный и закрытый) желательно на удалённой машине (откуда собираемся работать)  ~ssh-keygen
если пара ключей уже есть (для других серверов - github - использовать один и тотже ключь для разных сереверов),
 то необходимо публичный ключ скопировать в файл пользователя из группы sudo ~/.ssh/authorized_keys — на сервере
*ВАЖНО*
перед любыми действиями с настройками SSH держите второе окно с открытой SSH-сессией, так как при ошибочных действиях повторно подключиться к серверу вы сможете только через VNC-клиент.


далее необходимо настроить на сервере /etc/ssh/sshd_config — конфиг демона SSH.

Рекомендуемые для изменения директивы:
Port — смена порта, где располагается служба по умолчанию.
PubkeyAuthentication yes — включение авторизации по ssh-ключам.
PermitEmptyPasswords no — запрет использования пустых паролей.
PasswordAuthentication no — запрет авторизации по паролю в принципе.  (не меняйте, пока не убедитесь, что авторизация по SSH-ключам работает)

Опционально
ListenAddress 188.120.242.XXX — указываем конкретный IP, на котором будет располагаться служба. По умолчанию на всех.
PermitRootLogin no — запрет авторизации пользователя root.
AllowUsers User1 User2 — разрешение на подключение конкретных пользователей.

после правки файла конфигурации, необходимо его сохранить.
и перезагруить службу: $ sudo service ssh restart
после этого не закрывая терминал, подключиться по ssh к серверу из другого терминала: ssh user_sudo@ip-address -p22





***Изменение атрибутов файлов***
Помимо прав доступа и владельца каждый файл может иметь ряд атрибутов, определяемых на уровне файловой системы. Атрибуты показывают, какие операции могут или не могут проводиться с файлом в принципе, независимо от того, кто им владеет.
Посмотреть атрибуты файлов в текущей директории можно с помощью команды lsattr. Если запустить её без аргументов, она выведет атрибуты всех файлов в текущей директории. Если указать путь к файлу или папке, она перечислит свойства указанного файла или списка файлов в указанной папке соответственно:
lsattr example.txt 

Первые 20 символов в строке предназначены для отображения атрибутов файла.
Список атрибутов может отличаться в зависимости от файловой системы.  
Изменить атрибуты файла позволяет команда chattr:
chattr [модификатор][изменяемые атрибуты] [целевой файл или папка]

То есть, если нам нужно защитить какой-то важный файл от посягательств, можно использовать такую команду:
chattr +i example.txt

Если же нам нужно вернуть файл в нормальное состояние, нужно выполнить обратную операцию: 
chattr -i example.txt


*****Информацию о машине и ОС. Версия ядра и операционной системы*****
Проверить, какой версии ядро Linux вашего сервера, можно с помощью команды: 
uname -r


Эта же команда в подробном режиме покажет всю информацию: 
    имя ядра;
    имя сервера (hostname);
    релиз ядра;
    версию ядра;
    тип процессора;
    вид операционной системы.

uname -a

Узнать версию непосредственно установленного дистрибутива можно из конфигурационных файлов системы:
cat /etc/os-release

Краткую информацию об оборудовании можно посмотреть следующим образом:
lshw -short
lscpu

Посмотреть диск и его разделы так же просто:
lsblk -a

Для вывода информации о дисках можно использовать следующую утилиту: 
fdisk -l





