tail file.txt //output the last part of files по умолчанию показывает последние 10 строк
tail -f file.txt //-f follow выводит новые добавленые строки. чтобы закончить вывод ctrl+c
tail -1000f file.txt // следит за обновлениями файлов, показывает последние 1000 строк
tail --help

cat file1 // выводит на экран содержимое файла
cat file1 file2 //склеивает два файла

head file.txt // output the first part of files по умолчанию показывает первые 10 строк 
head -n 1000 file.txt // первые 1000 строк

touch file.txt // создание пустого файла
touch .file.txt //создание скрытого файла
> file.txt // создание файла
echo "hello mr Zhan" > file.txt // осторожно перезаписывает файл на hello mr Zhan
echo "добавление данных к файлу, а не перезапись" >> file.txt // добавление данных


/*** move file - перемещение файла  ***/
mv arg1.txt arg2_dir/ //перемещение файла в папку arg2_dir
mv file1.txt file2.txt //переименование файла
mv -i file1.txt file2.txt // предупредит о перезаписывании если файл существует
mv -t dest/ file1 file2 file3 // перемещение в папку всех файлов


/*** copy file and dir - копирование файла ***/
cp -i file1.txt dir/  //копирование файла в папку с предупреждением
cp file1 file2 //копирование содержимого файла1 в файл2, даже если файл2 не существует
cp -r dir1 dir2 //копирование содержимого дир1 в дир2 даже если его нет.


rm -i file.txt // удаление файла с предупреждением
rm -R моя_папка //удаление папки с файлами


ls -a //показывает список обычных и скрытых файлов

*** запуск нескольких команд за раз ***
Например, если нам нужно выполнить несколько команд последовательно, не обязательно вводить каждую по отдельности. Можно перечислить их через точку с запятой:
echo -n "Hello, "; echo "World!" // -n не будет вставлен символ перевода строки \n


Если нам нужно выполнить список зависимых друг от друга команд, для их разделения нужно использовать оператор &&.
В таком случае следующая команда в списке будет выполнена только при условии успешного выполнения предыдущей.
echo -n "Hello, " && echo "World!"


Оператор || действует наоборот — запускает следующую операцию при условии, что первая не выполнилась или завершилась с ошибкой.
wrongCommand || echo "Что-то пошло не так!"

Также можно запускать команды параллельно. Для этого в конец команд добавляется символ &, каждая команда заключается в круглые скобки, которые между тем разделяются между собой точкой с запятой:
(echo "Кто сказал, что убить двух зайцев" &); (echo "одним махом нельзя?" &)

******** запуск скрипта через ./scriptname **********
Чтобы запустить скрипт script.sh на сервере, нужно выполнить три шага: 
   1.Настроить права на запуск файла для пользователей:
    chmod +x ./script.sh 
    или для себя: chmod u+x ./script.py

   2. В начале файла скрипта необходимо указать какой интерпритатор его запустит: #!/bin/bash или же например: #!/bin/python3


   3. Запустить скрипт. Если вы находитесь в той же директории, где лежит скрипт, достаточно вызвать его по имени:
    ./script.sh

    В некоторых случаях нужно использовать команду sh либо указать путь к исполняемому файлу командной оболочки:
    sh ./script.sh
    либо
    /bin/bash ./script.sh
    Если вы находитесь в другой директории, для запуска нужно указать полный путь к скрипту. 


Чтобы иметь возможность запускать скрипт из любого места на сервере одной простой командой, можно создать для него алиас — короткую команду (псевдоним),
 которая будет ассоциироваться системой с полным вызовом скрипта.
Весь список существующих алиасов системы можно вывести с помощью команды alias

Создать свой постоянный алиас можно с помощью файла .bashrc, размещённого в домашнем каталоге вашего пользователя. Нужно открыть его для редактирования:
vi ~/.bashrc

В соответствующем разделе нужно добавить ваш алиас в следующем формате:
alias [короткая команда]='[исходная команда]'

*****Выполнение в фоновом режиме*****
Некоторые команды могут временно блокировать или усложнять работу в терминале. Например, когда запущенный процесс долго выполняется или выводит в консоль большие объёмы не особо полезного текста. Такие команды можно запускать в фоновом режиме. Тогда система будет выполнять их «на заднем плане», а вы продолжите работать и не будете ждать выполнения очередной операции.
Чтобы запустить команду в фоновом режиме, достаточно добавить в конце знак «&»:
sleep 3600 &

Если вам нужно переместить на задний план активный процесс, тогда нужно приостановить процесс его выполнения сочетанием Ctrl + Z и ввести в консоли команду bg

Вывести список команд, запущенных в фоновом режиме, можно с помощью команды 
jobs -l
Важно помнить, что фоновый режим привязан к сессии — при выходе из терминала все процессы, запущенные через него, будут прерваны. Этого можно избежать, выполнив нужную команду через nohup:
nohup sleep 3600 &


Команды, запущенные в фоновом режиме, при наличии ошибок будут отправлять их в терминал — что не всегда удобно. Можно перенаправить вывод ошибок. В следующем примере ошибки вместо вывода в терминал будут записаны в файл error.log:
sleep 3600 2>>error.log &

Вернуть процесс на передний план можно, введя команду fg. Если процессов несколько, потребуется указать идентификатор задачи ID. Его можно посмотреть в выводе команды jobs -l (число в квадратных скобках).
fg %ID





типы файлов в линукс:
1. обыкновенные файлы;
2. дириктории;
3. символьные устройства;
4. блочные устройства;
5. соккеты;
6. каналы;
7. символьные ссылки;

Посмотреть тип файла: ls -l

утилита ncdu - показывает размер папки и вложенных файлов - необходимо установить
-r значит рекурсивно (удалить файлы в папке и во вложенных папках тоже) - осторожное применение

ls -R //показывает все файлы и папки рекурсивно


мягкие сслыки и жёсткие ссылки
мягкие ссылки как ярлыки в windows - файл с типом ссылка, который указывает на другие файлы.
Они хранят адрес файла. Мягкие они называются потому что они за файлом не следят.
Если переместить, удалить файл - мягкая ссылка перестанет работать.
ln -s полный_адрес/file link //создание мягкой ссылки

жёсткие ссылки работают не с адресами файлов, а с индексными дескрипторами.
Хранит метаданные в том числе и место на диске.
У каждого файла есть индексный дескриптор (можно увидеть ls -li)
ln file.txt hardlink// создание жёсткой ссылки
теперь inode совпадают у файла и жёсткой ссылки ls -li
 при копировании файлов inode у них различаются. Теперь файлы живут каждый по себе.

-----USERS-----
sudo useradd zip // добавление нового пользователя в ОС, без домашней директории и без пароля
sudo useradd -m username // с домашней директирией

cat /etc/passwd //посмотреть на пользователя, есть ли пароль
sudo passwd username // добавить пользователю пароль Unix по умолчанию

sudo userdel username //удаление пользователя
sudo userdel -r username //удаление вместе с домашней директорией

su username //переключиться на нового пользователя

--groups--
cut -d: -f1 /etc/passwd //посмотреть список пользователей

sudo groupadd lawyers // создали группу юристов
getent group // проверка создания группы

sudo usermod -aG lawyers username //добавили пользователя в группу 
getent group lawyers // проверяем что пользователь добавился в группу

sudo gpasswd --delete username lawyers //удаление пользователя из группы

----- Права доступа -----
---смена собственника файла---
ls -la
sudo chown username:group test-1.sh
ls -la

sudo chmod g=r file_or_dir #доступ для чтения для всей группы
g=w - вносить изменения для группы
g=x - выполнять для группы

o - other 
o+r
o+w
o+x

sudo chmod a+x file.sh //исполнение всем группам (a - all)
sudo chmod g-x file.sh //запрет исполнения всем группам
sudo chmod o-x file.sh //запрет исполнения другим

 user	group	other
-rwx	rwx	rwx
 111	111	111
 7	7	7

 
-rwx	---	---
 7	0	0

-rw-	rw-	rw-
 110	110	110
 6	6	6

sudo chmod 666 file.sh //запрет исполнения

---grep and find---
find - для поиска файлов по именам и метаданным - рекурсивно по всем папкам вниз
find #без аргументов покажет список всех файлов в директории откуда был запуск
find -name "filename" # из директории где типо есть файл
find -iname "filename" # без учёта регистра

find -name "test*" or find -iname "test*" #регулярные выражение

find -type # 7 типов файлов
find . -type d #найти в текущей папке все папки
find . -type f #вывести файлы

find . -type d -name "dir*"
 
поиск по размеру файла
find . -size +1M # больше 1 Мега байта
find . -size -1M

find . -emty # ничего не содержит
find . -mmin -10 #модификация меньше 10 минут назад
find . -mtime -5 # 5 дней назад


grep - чаще всего используется для поиска по содержимому файла

ps aux | grep process_name # поиск и вывод нужного процесса


******************process*************
состояния: 
1. Готовность
2. Выполнение
3. Ожидание

виды: 
*процессы запущенные пользователем
*демоны (процессы запущенные системой)

посмотреть дерево процессов: pstree
системные вызовы:
*fork
*exec
*exit
*kill

sleep 100 & # процесс засыпает в фоне
nohup sleep 100 & # процесс не завершится при закрытии терминала


jobs -l
fg pid #выводы запущеных процессов

top, htop # утилиты просмотра процессов и их атрибутов

kill pid # экстренное завершение процесса

ps - это утилита отображающая запущенные на данный момент процессы.
Выводит снимок состояния процессов.

ps # без ключей выводит инфу о запущенных процессах конкретной оболочки, в которой я нахожусь.
ps -A или ps -e #выводит список всех активных процессов на linux системе в generic (Unix/Linux) формате.
ps au или ps aux #-||- в bsd формате

ps -x #вывод всех процессов владельцем которых является запустивший команду.
ps -fu root или ps -fU 0 #вывод всех процессов конкретного пользователя по его имени или id
ps -eo pid,user,cmd #id процесса, пользователь, команда  
ps aux | grep pid

pkill process_name

killall chrome

pgrep chrome

pgrep -u zip1982b # посмотреть процессы запущенные пользователем.

uptime # сколько пользователей залогинилось


************** ssh **********************
чтобы подключиться к серверу по ssh, необходимо что бы на сервере был установлен сервер ssh и включен.
как правило первый вход (как администратор) (имея логин и пароль) происходит по логину и паролю: ssh root@ip-address <enter> далее вводим пароль
необходимо создать другого пользователя (чтобы не работать под root - в целях безопасности) и включить его в группу sudo (если её нет то создать)


 
далее необходимо настроить вход для пользователей по ssh ключам:
необходимо сгенерировать пару ключей (публичный и закрытый) желательно на удалённой машине (откуда собираемся работать)  ~ssh-keygen
если пара ключей уже есть (для других серверов - github - использовать один и тотже ключь для разных сереверов),
 то необходимо публичный ключ скопировать в файл пользователя из группы sudo ~/.ssh/authorized_keys — на сервере
*ВАЖНО*
перед любыми действиями с настройками SSH держите второе окно с открытой SSH-сессией, так как при ошибочных действиях повторно подключиться к серверу вы сможете только через VNC-клиент.


далее необходимо настроить на сервере /etc/ssh/sshd_config — конфиг демона SSH.

Рекомендуемые для изменения директивы:
Port — смена порта, где располагается служба по умолчанию.
PubkeyAuthentication yes — включение авторизации по ssh-ключам.
PermitEmptyPasswords no — запрет использования пустых паролей.
PasswordAuthentication no — запрет авторизации по паролю в принципе.  (не меняйте, пока не убедитесь, что авторизация по SSH-ключам работает)

Опционально
ListenAddress 188.120.242.XXX — указываем конкретный IP, на котором будет располагаться служба. По умолчанию на всех.
PermitRootLogin no — запрет авторизации пользователя root.
AllowUsers User1 User2 — разрешение на подключение конкретных пользователей.

после правки файла конфигурации, необходимо его сохранить.
и перезагруить службу: $ sudo service ssh restart
после этого не закрывая терминал, подключиться по ssh к серверу из другого терминала: ssh user_sudo@ip-address -p22





***Изменение атрибутов файлов***
Помимо прав доступа и владельца каждый файл может иметь ряд атрибутов, определяемых на уровне файловой системы. Атрибуты показывают, какие операции могут или не могут проводиться с файлом в принципе, независимо от того, кто им владеет.
Посмотреть атрибуты файлов в текущей директории можно с помощью команды lsattr. Если запустить её без аргументов, она выведет атрибуты всех файлов в текущей директории. Если указать путь к файлу или папке, она перечислит свойства указанного файла или списка файлов в указанной папке соответственно:
lsattr example.txt 

Первые 20 символов в строке предназначены для отображения атрибутов файла.
Список атрибутов может отличаться в зависимости от файловой системы.  
Изменить атрибуты файла позволяет команда chattr:
chattr [модификатор][изменяемые атрибуты] [целевой файл или папка]

То есть, если нам нужно защитить какой-то важный файл от посягательств, можно использовать такую команду:
chattr +i example.txt

Если же нам нужно вернуть файл в нормальное состояние, нужно выполнить обратную операцию: 
chattr -i example.txt


*****Информацию о машине и ОС. Версия ядра и операционной системы*****
Проверить, какой версии ядро Linux вашего сервера, можно с помощью команды: 
uname -r


Эта же команда в подробном режиме покажет всю информацию: 
    имя ядра;
    имя сервера (hostname);
    релиз ядра;
    версию ядра;
    тип процессора;
    вид операционной системы.

uname -a

Узнать версию непосредственно установленного дистрибутива можно из конфигурационных файлов системы:
cat /etc/os-release

Краткую информацию об оборудовании можно посмотреть следующим образом:
lshw -short
lscpu

Посмотреть диск и его разделы так же просто:
lsblk -a

Для вывода информации о дисках можно использовать следующую утилиту: 
fdisk -l


******* cron - планировщик задач ********

crontab -e #для редактирования файла crontab - лучше редактировать этой командой

Вывод содержимого текущего файла позволяет команда: crontab -l

Таблица crontab состоит из 6 колонок, которые разделяются пробелами или табуляторами.
Первые пять колонок отвечают за время выполнения, соответственно, минута, час, день месяца, месяц, день недели.
В них может находиться: число, список чисел (1,2,3), диапазон чисел (1-3), символы * или /.
Все остальные символы в строке интерпретируются как выполняемая команда с ее параметрами –
 можно указать как саму команду (например, echo “Доброе утро”), так и путь к исполняемому скрипту.

Ниже приведены примеры настройки и работы cron:
0 17 * * 1-5 echo “Рабочий день закончен – эта надпись выводится в 17:00 с понедельника по пятницу”
15 6 * * sun echo “Выполняется в 6:15 в воскресенье”
30 12,13 * * 1,3 echo “Эта надпись выводится в понедельник и среду в 12:30 и 13:30”
0-59 * * * * echo “Выполняется ежеминутно”


*******Изучение сетевых интерфейсов и утилит*********
Краткий конспект предыдущего видео
Посмотреть сетевые интерфейсы можно с помощью команды

ip link

Настройка ip-адреса для Debian/Ubuntu:
Откройте файл /etc/network/interfaces и найдите следующие строки:

iface eth0 inet static

Эта строка и предыдущая задает сетевой интерфейс, он у нас основной
Далее проверяем или записываем, если этих строк нет строки:   

address 10.10.10.10  - здесь указывается основной Ipv4-адрес
netmask 255.255.255.0  - указывается маска
gateway 10.10.10.1 - шлюз

pointopoint - в случае, если в сети, где расположен ваш сервер используется технология VPU. На серверах с VPU нет общего broadcast-домена, все адреса настраиваются с маской /32. В этом случае сервер считает, что он один в своей сети, и не будет посылать пакеты напрямую узлам — всё будет пересылаться исключительно через шлюз. Однако, при этом нужно явно задать маршрут до шлюза, поэтому просто указать шлюз недостаточно, требуется параметр pointopoint. В нашем случае это 10.10.0.1

Ниже можете увидеть строку

auto eth0:1 - число после двоеточия означает порядковый номер дополнительного адреса, начиная с 0, еще эти интерфейсы называют алиасами, или псевдонимами по-русски, так как на деле в интернет мы идем все по тому же основному сетевому порту, просто можем “представиться” другим адресом

iface eth0:N inet static

    address 10.10.10.11

    netmask 255.255.255.255

После изменений, для применения изменений можно выполнить команду

systemctl restart networking

Для некоторых же изменений, например смены основного IP-адреса, иногда сервер нужно перезагрузить.

Настройка ip-адреса для Centos:

Откройте файл /etc/sysconfig/network-scripts/ifcfg-eth0 и найдите строки

DEVICE="eth0"

Эта строка задает сетевой интерфейс, он у нас основной.
Следующие строки:
ONBOOT="yes" - чтобы сеть запускалась при старте системы
TYPE="Ethernet" - тип интернет-подключения, для виртуальных машин это почти всегда Ethernet
IPADDR=<Основной IP адрес машины> - указывается основной IPv4 адрес машины
NETMASK=255.255.255.0 - указывается маска (255.255.255.0 - лишь пример), либо
PREFIX=24 - также указывается маска, но формате префикса подсети (24 - лишь пример)
GATEWAY0=37.73.130.1 - шлюз, 37.73.130.1 - лишь пример

Это стандартные параметры, в случае, если в сети, где расположен ваш сервер используется технология VPU, добавляется строка

SCOPE="peer 10.0.0.1" - в нашем примере это 10.0.0.1
Также для VPU нужно добавить прямой маршрут в файле /etc/sysconfig/network-scripts/route-eth0 (если его нет - создать) и заполнить его данными:

ADDRESS0=0.0.0.0
NETMASK0=0.0.0.0
GATEWAY0=10.0.0.1

После изменений, для применения изменений можно выполнить команду

systemctl restart network.service

Примененные изменения можем увидеть командой ip a

Теперь проверим, указан ли шлюз по умолчанию. Команда ip r покажет имеющиеся маршруты:

Утилита traceroute
Установка
Debian/Ubuntu:
apt-get install traceroute



Утилита mtr

Установка Debian/Ubuntu:
apt install mtr-tiny

Утилита speedtest
Debian/Ubuntu:

curl -s https://install.speedtest.net/app/cli/install.deb.sh | bash
apt install speedtest-cli

Запускаем:
speedtest

***Полезные команды при работе с пакетным менеджером apt***

    apt remove – удалить пакет без измененных вами конфигов.
    apt purge – полностью удалить пакет, вместе со всеми его конфигурационными файлами;
    apt autoremove – очистить ненужные пакеты;
    apt autoclean – очистка кэша пакетов;
    apt upgrade – обновить пакет до актуальной версии, если пакет не указан будет обновлено всё.
    apt list выводит список доступных пакетов, а apt list --installed - установленных
    apt search cowsay – поиск пакетов с именем, которое включает ключевое слово “cowsay”;
    apt show cowsay – посмотреть информацию о пакете с именем “cowsay”;;
    apt edit-sources – открыть с настройками репозиториев в текстовом редакторе.
    apt build-dep – установить зависимости необходимые для сборки выбранного пакета;
    apt-cache depends - посмотреть зависимые пакеты.



